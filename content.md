## Вопросы

Какой цвет у тени элемента по умолчанию?
совпадает с цветом текста внутри элемента

К чему по умолчанию привязана система координат абсолютно спозиционированного элемента?
к ближайшему родительскому элементу с position отличной от static

Поговорим о JavaScript. К какому типу данных относится undefined?
это отдельный тип данных с единственным значением




# Container queries
## Не гуглите контейнерные запрос
Так как начнёте работать с Kubernetes и Docker

## История
CQ - достаточно спорная тема и чтобы понять из нужно немного погрузится в историю.

В 2010 году появился Responsive Design и в этот момент был изменён наш взгляд на веб-дизайн впринципе.
С этих самых пор веб-разработчики могут написать один стилевой файл и описать все возможные состояния интерфейса - смартфоны, планшеты, десктопы.

До 2012
вы могли наблюдать одни и те же медиа-запросы. Сетки сайтов были однотипными, но это было только зарождение технологии.
В это же время веб-разработчики начали замечать ограничения использования медиа-запросов для создания адаптивных сайтов.

 В 2013
  году многие разработчики стали переходить на разработку проектов с компонентным подходом, а не проектоную. Тогда же и появился запрос на адаптивное перестроение компонентов/элементов, а не интерфейса от вьюпорта.
Начали предлагаться медиа-запросы не от viewport, а от элемента. Working Group
 начинает работать над документом под название Element Queries.

 Но было очень много проблем.
 Вот можно взять к примеру календарь и увидеть какой он адаптивный. Но он хорошо выглядит только потому что занимает 100% ширины экрана.
 Если поместить календарь на часть экрана, то есть использовать как виджет, то уже становится всё гораздо хуже. Ведь MQ не сработает для мобильного, хотя мобильное состояние описано.

 Все начали проникатся идеей Element Queries
  и начали писать полифилы и проблема всех полифилов была в том, что синтаксис был совсем не похож на CSS
   ,а был каким-то надуманным. Хотелось бы, чтобы он был совместим с CSS
    и мог переродится уже в виде официальной спецификации. Но как вы знаете такое происходит редко. Стрелочные функции из метеора.

В 2014 начались усилия по стандартизации Element Queries http://ricg.io/#:~:targetText=Responsive%20Issues%20Community%20Group,fast%2C%20accessible%2C%20responsive%20websites.
Но их усилия были тщетны, так как браузерные вендоры и CSS Group не хотели внедрят предложенный документ.

В 2015 году было объявлено, что Element Queries в предложенном виде были уже устаревшими.
Группа поняла, что проиграла битву и ...
переименовала документ с Element Queries на Container Queries (https://github.com/WICG/cq-usecases/commit/e0d2faf7fa1df7e98c7e6ff7b59771219623c345#diff-04c6e90faac2675aa89e2176d2eec7d8)

Немного поменялась и взаимодествие, если раньше мы влияли на элемент, то теперь на непосредственно к родителю, а уже внутренности менялись.
И вроде как решились некоторые проблемы для реализаци в браузерах, но всё равно вендоры сопротивлялись к реализации.
Но как мы знаем спрос пораждает предложение и многие ТОПовые разработчики были заинтересованы в технологии и просили реализовать фичу. Доводы были такие, что разработчики готовы были отказаться от 50% своих MQ в пользу CQ.

Но web developer vs browser maker
Браузерные разработчики не видят будущего в CQ и вот про какие две проблемы они рассказывают:
1. Это бесконечный цикл
2. Разрушение каскада

## Бесконечный цикл
### Пример 1
```css
.element {
    width: 500px;
}
```

```css
element:min-width(500px) > {
    width: 499px;
}

```
Если мы уменьшим элемент на 499
 пикселей, то селектор больше не будет совпадать. Но это также обозначает, что мы вернулись к первому селектору и он становится 500px и теперь начинает работать условие. Думаю вы уже поняли...

### Пример 2
Иногда размеры контейнера определяет дочерний элемент

```css
.container {
    float: left
}

.element {
    width: 500px;
}

.container:min-width(500x) > .element {
    width: 499px;
}
```
Контейнер имеет ширину ребёнка. Поэтому они оба по 500px.
Следующее правило говорит, что если ширина контейнера состовляет 500px
 или больше, то ширина дочернего должна быть 499px и это изменит ширину container.
 И у нас всё таже самая проблема.

## Разрушение каскада
Для того, чтобы понять эту тему нужно разобаться как CSS и HTML превращается в то, что вы видите на экране.
HTML/CSS -> Style -> Layout -> Paint
Самое главное, что нам нужно понять в этапах - это то что они последовательны и что пока не закончится предыдущий не начнётся новый.

### Style
Давайте рассмотрим фазу стилей(Style).
На этом этапе браузер рассматривает DOM
 и стили. Сравнивает, что чему соответствуют. Это мы знаем как каскад. Некоторые сайты имеют тысячи правил стиля и элементов DOM, так что это очень важно для понимания проблемы.
 Важно с точки зрения проивзодительности.

 ```html
<section>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </ul>
</section>
```
И проблема в том, что прежде чем определить стили для ребенка нужно определить все стили родителя. Ведь некоторые свойства наследуются, а некоторые нет.
Но на элементы как вы знаете действуют свойства по умолчанию и свойства браузера.
Section
Ul
И самое интересное, когда мы добираемся до li. Второе правило padding переопределяется. Но также li
 наследует цвет от ul. Может быть это было сложно, но на самом деле вы всё это могли наблюдать на панели computed
  в elements свеого браузера.

### Layout
лайут отвечает за позиционирование элементов. вычисляются прямоуголники - место которое займёт DOM-элемент.
Section начинается с левого верхренго угла (0,0), занимает ширину 600 (0,0,600
), но мы не знаем высоту, потому что нужно пройтись по всем дочерним элемента.
ul занимает также как section
но когда добираемся до li, то уже появляются ячейки и размеры по высоте.
Напомню, что все шаги рендеринга последовательны и не могут выполнится раньше предыдущего шага. Так и здесь - мы не могли построить лайоут, если бы не поработали со стилями.


## Реализуем Container Queries
```css
ul:min-width(500px) > li {
    flex: auto;
}
```
Есть два свойства flex
, но какое из них сработает? Единственный способо ответить на этот вопрос это узнать на сколько он широкий. Он больше 500 или меньше?
Посколько мы ещё не прошли шаг layout мы не можем этого узнать.
В этом случае нам нужно перейти из последовательного рендеринга к циклическому.
В этом случае на наа Style нужно перейти в Layout
, который может изменить каскад и нам нужно будет вернуться обратно к Style
. И так несколько раз пока все не уляжется как нужно.

Это очень медленно, чем последовательнаый процесс выполнения, а мы за производительность. Собственно, веб-разработчики предлагают замедлить отрисовку интерфейса. Поэтому браузерные разработчики и отказываются.

Но на самом деле в том, что браузеры всё-таки придумывают как оптимизироват этот процесс.

В 2015  начали делать спецификацию CSS Contaiment
, которая позволяет разработчикам рассказывать браузерам какие части макета страницу не зависят от других частей. Это потенциально позволяет избегать цикличности в отрисовке.
Ведь элемент теперь можно указать размер и подсказать браузеру, что не что не может затронуть размер контейнера, даже его элементы, независимо насколько они велики или малы.

Внедрение новых фич для решения проблем продолжилось и в 2016году. Хром начал работать на ResizeObserver
https://caniuse.com/#feat=resizeobserver
. Которая позволяет контролировать размер элемента на странице. Раньше мы могли наблюдять изменения во всем окне, но элементы могут изменяться даже если мы не изменяем окно браузера.

## Будущее
У нас появились новые фичи для решения проблем с цикличностью, но всё ещё не появилось CQ.
На самом деле CQ были всегда ... TODO

Показать пример с гипотетическим CQ.
Показать пример с классами.
Показать пример контейнера. Класс MD, LQ добавляется только, когда изменяется размер элемента.

Можем ли мы сделать это уже сейчас и как? Вот тут нам и поможет ResizeObserver.
Показать код resizeObserver.
1. Создаем экземпляр
2. Функция которая вызывется, когда наблюдаемые элементы изменяются размер
3. Можно передать список элементов
4. Передаем брейкпоинты
5. Проходимся по элементам сравниваем с брейкпоинтами
6. меняем класс если совпадение было
7.  Запускам resizeObserver для нужных элементов

Но даже если JS отключится контейнеры всё равно будут работать.
Но есть проблема мы с вами пишем в CSS, а про JS не хотим.

## Дизайн
Теперь у нас получается, что интерфейс состоит не из макета, а из компонентов в которых описаны все воможные состояния. И не важно где это применяется в React, HTML/CSS или других крутых библиотеках.

## Итого
1. разработчики до сих не получили Container Queries в том виде в каком хотели
2. Но мы научились делать его реализацию с помощью ResizeObserver
3. Совсем недавно произошёл перезапуск Container Queries, но уже на уровне W3C
## Полезные ссылки
### Конвеер рендеринга
* https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing?hl=ru
* https://developers.google.com/web/fundamentals/performance/rendering/simplify-paint-complexity-and-reduce-paint-areas?hl=ru
### CSS Containment
* https://www.w3.org/TR/css-contain-1/
* https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Containment
* https://css-live.ru/articles/css-izolyaciya.html
* https://habr.com/ru/post/309042/
### ResizeObserver
* https://drafts.csswg.org/resize-observer-1/
* https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver
### Container queries
* https://wicg.github.io/cq-usecases/
